# Utility Functions (Could be useful outside of this script.
. $HOME/.bash/.bash_constants # A list of constants tuo have in theenv
. $HOME/.bash/.bash_array_functions # Import the array functions.
. $HOME/.bash/.bash_env_functions # The environment interrogation functions.


# Related global vars.
## Default log files.
unset DEBUG # Turn db* logging off. Set to any value to turn on.
export _debugLog="$HOME/.log/dbout.log"
unset funcTrace # Turn functionTracingDebug header logging off. Set to any value to turn on.
export _functraceLog="$HOME/.log/functrace.log"
export _describeScriptLinesMax=15


# Debugging & Program info
# ↓↓↓ def db()
db() {
    local _DOCSTRING="Log a debug message. Takes optional alternate logfile as 1st arg."
    local _USAGE="Usage: db [_log=/alternate/logfile] <message>"

    local  message logfile caller

    if [[ -v FUNCNAME[1] ]]; then # If we called from inside a function.
        caller="${FUNCNAME[1]}"
    fi

    logfile="$_debugLog" # Default that can be overridden by argument options.
    while [[ "$1" =~ ^_.*= ]]
    do
        case "$1" in
            _log=*)
                logfile=${1#_log=}
                shift
                ;;
            _caller=*)
                caller=${1#_caller=}
                shift
                ;;
            --status)
                if [[ -v DEBUG ]]; then
                    echo "${green}ON${normal}: $_debugLog"
                else
                    echo "${red}OFF${normal}: $_debugLog"
                fi
                return 25
                ;;
        esac
    done

    if [[ "$caller" != '' ]]; then
        caller="[$red$caller$normal] " # Color the caller red.
    fi

    message="$*"

    if [[ -v DEBUG ]]; then
        echo "${caller}${message:-BLANK}" >> "$logfile"
    fi
}
# ↑↑↑ END db
# ↓↓↓ def dbFail()
dbFail() {
    local _DOCSTRING="Log a debug SUCCESS message. Takes optional alternate logfile as 2nd arg."
    local _USAGE="Usage: db <message> [logfile="$debugLog"]"
    local  message logfile
    minimumArguments 1 "$@" || return 3

    local caller logarg

    if [[ -v FUNCNAME[1] ]]; then # If we called from inside a function.
        caller="_caller=${FUNCNAME[1]}" # String to send to standard db() to tell it who called us.
    else
        caller="_caller=" # This will expand into a blank, which will tell db() to not print [caller] portion.
    fi

    if [[ "$1" =~ ^_log= ]]; then # Peal off the logfile argument. The rest of the args are the ones fed to the call we are logging about.
        logfile=${1#_log=}
        shift
    else
        logfile="$_debugLog"
    fi

    message="$*"
    logarg="_log=$logfile"

    db "_log=$logfile" "$caller" "${bold}${red}FAIL${normal} -- ${message:-BLANK}" 
}
# ↑↑↑ END dbFail
# ↓↓↓ def dbSuccess()
dbSuccess() {
    local _DOCSTRING="Log a debug SUCCESS message. Takes optional alternate logfile as 2nd arg."
    local _USAGE="Usage: db <message> [logfile="$debugLog"]"
    local  message logfile
    minimumArguments 1 "$@" || return 3

    local caller logarg

    if [[ -v FUNCNAME[1] ]]; then # If we were called from inside a function.
        caller="_caller=${FUNCNAME[1]}" # String to send to standard db() to tell it who called us.
    else
        caller="_caller=" # This will expand into a blank, which will tell db() to not print [caller] portion.
    fi

    if [[ "$1" =~ ^_log= ]]; then # Peal off the logfile argument. The rest of the args are the ones fed to the call we are logging about.
        logfile=${1#_log=}
        shift
    else
        logfile="$_debugLog"
    fi

    message="$*"
    logarg="_log=$logfile"

    db "_log=$logfile" "$caller" "${bold}${green}SUCCESS${normal} -- ${message:-BLANK}" 
}
# ↑↑↑ END dbSuccess()
# ↓↓↓ def dblv()
dblv() {
    local _DOCSTRING="Send the listVarsLong output to the debugLog like db() does."
    local _USAGE="Usage: dblv <varName>"
    functionTracingDebug "$@"

    minimumArguments 1 "$@" || return 3

    local arg caller
    declare -a options
    declare -a vars

    if [[ -v FUNCNAME[1] ]]; then # If we called from inside a function.
        caller="_caller=${FUNCNAME[1]}" # String to send to standard db() to tell it who called us.
    else
        caller="_caller=" # This will expand into a blank, which will tell db() to not print [caller] portion.
    fi

    for arg in "$@"
    do
        case "$arg" in
            _*=)
                options+=("$arg")
                ;;
            *)
                vars+=("$arg")
                ;;
        esac
    done

    db "${options[@]}" "$caller" "$(listVarsLong "${vars[@]}")"
}
# ↑↑↑ END dblv

# ↓↓↓ def debugLog()
debugLog() {
    local _DOCSTRING="Watch the default debug log file for new output."
    local _USAGE="Usage: watchDebugLog "
    functionTracingDebug "$@"

    if [[ "$#" == 0 ]]; then # If no arguments supplied
        echo "$_debugLog" # Print the currently assigned debug log file
        return 0
    fi
    while [[ "$#" -gt 0 ]]
    do
        case "$1" in
            --log|-l)
                local connonicalPath="$(realpath "$1")"
                if regularWritable "$connonicalPath"; then  # If is regular file, and writable
                    _debugLog="$connonicalPath" 
                    return 0
                else
                    return 1
                fi
                ;;
            --clear|-c)
                local CLEAR='true'
                ;;
        esac

        # Process --clear option. 
        #     Because the log file might have been changed by another
        #     option, we need to do this after all args are parsed.
        if [[ -v CLEAR ]]; then
            if :>"$_debugLog"; then
                echo "Cleared: $_debugLog"
                return 0
            else
                echo "Could not clear: $_debugLog"
                return 1
            fi
        fi
    done
}
# ↑↑↑ END debugLog

# ↓↓↓ def functionTracingDebug() ## Used in ultisnip generated function header. ##
functionTracingDebug() {
    local _DOCSTRING="Logs information about the function call this function was called from."
    local _USAGE="Usage: functionTracingDebug [logfile="$debugLog"] <message>"

    # Locals
    local logfile args indent depth callingFunction callerOfCaller calledByString
    local definedInSourceFile callingLineNumber calledInSourceFile

    if [[ ! -v funcTrace ]]; then # Are we enabled?
        return 0
    fi

    if [[ "$1" =~ ^_log= ]]; then # Peal off the logfile argument. The rest of the args are the ones fed to the call we are logging about.
        logfile=${1#_log=}
        shift
    else
        logfile="$_functraceLog"
    fi

    args=( "$@" )

    # Check for recursive calls of this function
    for (( funcNumber = 1; funcNumber < ${#FUNCNAME[@]}; funcNumber++ ))  # For each function in the call stack other than ourselves
    do
        funcName="${FUNCNAME[$funcNumber]}"
        if [[ "$funcName" == 'functionTracingDebug' ]]; then # If that name is our name, aka, we've been called by something that was called by us
            return 0 # Just return because it is recursive otherwise.
        fi
    done
    
    # Callers
    callingFunction="${FUNCNAME[1]}"
    if [[ -v FUNCNAME[2] ]]; then # If the calling function was called by a function
        callerOfCaller="${FUNCNAME[2]}"
        calledByString=" Called by: $blue$callerOfCaller$normal"
    fi

    # Calling function source
    depth="$(( ${#FUNCNAME[*]} - 1 ))"
    definedInSourceFile="${BASH_SOURCE[1]}"

    # Output
    printf "[Depth: $depth] Entering ${red}${callingFunction}${normal}$calledByString\nDefined in: $definedInSourceFile\n$(listArgsLong "$@")\n\n" | indentIt "$depth" >> "$logfile"
}
# ↑↑↑ END functionTracingDebug
# ↓↓↓ def functrace()
functrace() {
    local _DOCSTRING="Displays or sets the funcTrace functionality."
    local _USAGE="Usage: functrace [-lcvh] [off/on]"
    functionTracingDebug "$@"

    # No args --> print status
    if [[ "$#" -eq 0 ]]; then # We got no arguments
        if [[ -v funcTrace ]]; then # If function tracing is on
            printf "Function logging is ${green}ON${normal}\n"
            
        else
            printf "Function logging is ${red}OFF${normal}\n"
        fi
        return 0
    fi

    # Parse options
    while [[ "$#" -gt 0 ]]
    do
        case "$1" in
            [yY]|yes|YES|on|On|ON)
                local arg_on=true
                shift
                ;;
            [nN]|no|NO|[fF]|off|OFF)
                local arg_off=true
                shift
                ;;
            --log|-l)
                local opt_log=true
                if [[ "$2" =~ ^[./] ]]; then # If we were sent a path
                    local opt_logpath="$2"
                    shift 2
                else
                    shift 1
                fi
                ;;
            --clear|-c)
                local opt_clear=true
                shift
                ;;
            --view|-v)
                local opt_view=true
                shift
                ;;
            --help|-h)
                cat <<-EOF
						functrace: functrace [--help, -h] [--log, -l [/path/to/logfile]] [--clear, -c] [on|off]
						    Manipulates the function tracing facilities.
						
						    Arguments:
						      on, yes, o, y       Turn on logging
						      off, no, f, n       Turn off logging
						
						    Options: 
						      -h, --help          List this help screen.
						      -l, --log [/path]   Prints the path to the current log file.
						                            If given a path argument, sets the log
						                            file for this environment and subshells.
						      -c, --clear         Empty the logfile (optionally specified on the same commandline)
						      -v, --view          Tail -f the functrace log file.
						
						    The functrace system uses a function functionTracingDebug() that is explicitly
						    called at the top of a function:
						
						      myfunc() {
						          functionTracingDebug "\$@"
						          rest_of_code...
						          return 0
						      }
						
						    This loggs information about the enclosing function call to the log file
						    set in \$_functraceLog. This environment variable is manipulated by this 
						    command's --log option.
						
						    Logging can be toggled by sending an ON or OFF argument.
						
						EOF
                return 0
        esac

        # -l, --log
        if [[ -v opt_log ]]; then
            if [[ -v opt_logpath ]]; then
                local connonicalPath="$(realpath "$opt_logpath")"
                if regularWritable "$connonicalPath"; then  # If is regular file, and writable
                    export _functraceLog="$connonicalPath" 
                else
                    printf "Supplied path is not a regular writable file." >&2
                    return 1
                fi
            else # Without an argument to -l, just print the current path to log file.
                echo "$_functraceLog"
                return 0
            fi
        fi

        # -c, --clear
        #     Because the log file might have been changed by another
        #     option, we need to do this after all args are parsed.
        if [[ -v opt_clear ]]; then
            :>"$_functraceLog"
        fi
        
        # -v, --view
        if [[ -v opt_view ]]; then # -v, --view option execution
            tail -f "$_functraceLog"
        fi

        # [on]
        if [[ -v arg_on ]]; then
            export funcTrace=true
        fi

        # [off]
        if [[ -v arg_off ]]; then
            unset funcTrace
        fi
    done
}
# ↑↑↑ END functrace

# ↓↓↓ def stackTrace()
stackTrace() {
    ## Prints a stack trace. Needs work... TODO Make this better.
    functionTracingDebug "$@"
    local idx
    for (( idx=1; idx<="${#FUNCNAME[*]}"; idx++ ))
    do
        caller "$idx"
    done
}
# ↑↑↑ END stackTrace
# ↓↓↓ def debugStringItAlong()
debugStringItAlong() {
    local _DOCSTRING="Checks the snap date vars. Very specific to the rotate-snapshots script debugging session."
    local _USAGE="Usage: debugStringItAlong "
    functionTracingDebug "$@"

    stringitAlong="$snapYear-$snapMonth-$snapDay--$dateCode"
    db "$stringitAlong"
}
# ↑↑↑ END debugStringItAlong

# UI utilities
# ↓↓↓ def setColors()
setColors() {
    ## Sets global variables for term specific color escape codes.
    ### Variables are in the global scope.
    functionTracingDebug "$@"
    if [[ ! -v colorsSet ]]; then
        if [[ -x /usr/bin/tput ]] && tput setaf 1 >&/dev/null; then # if we have tput, and we have a color capable terminal
            # The following logic chain syntax only does the last thing if all the succeed, and the || <command>  if any of them fail.
            red=$(tput setaf 1) &&
            alertRed=$(tput setaf 196) &&
            rustyRed=$(tput setaf 95) &&
            seriouslyRed=$(tput setaf 88) &&
            liabilityPink=$(tput setaf 211) &&
            green=$(tput setaf 2) &&
            aquaMarine=$(tput setaf 79) &&
            cvagDark=$(tput setaf 65) &&
            cvagMed=$(tput setaf 78) &&                 # AKA, "Electric".
            cvagLight=$(tput setaf 114) &&
            cvagLightest=$(tput setaf 194) &&
            yellow=$(tput setaf 3) &&
            peach=$(tput setaf 224) &&
            warmOrange=$(tput setaf 173) &&
            travexOrange=$(tput setaf 214) &&
            lemon=$(tput setaf 179) &&
            taxexYellow=$(tput setaf 11) &&
            blue=$(tput setaf 4) &&
            blueMidnight=$(tput setaf 17) &&
            dodgerBlue=$(tput setaf 33) &&
            fancyBlue=$(tput setaf 21) &&
            slsbDark=$(tput setaf 24) &&
            slsbMed=$(tput setaf 31) &&                 # AKA, "Starry night".
            slsbLight=$(tput setaf 116) &&
            slsbLightest=$(tput setaf 188) &&
            purple=$(tput setaf 5) &&
            princePurpleDarkest=$(tput setaf 53) &&
            princePurpleDark=$(tput setaf 90) &&
            princePurple=$(tput setaf 127) &&
            princePurpleLight=$(tput setaf 200) &&
            powder=$(tput setaf 152) &&
            boldOrange=$(tput setaf 178) &&
            sunFlower=$(tput setaf 220) &&
            tinGray=$(tput setaf 102) &&
            cyan=$(tput setaf 6) &&
            bold=$(tput bold) &&
            normal=$(tput sgr0) &&
            colorsSet=true ||
            return 1 # Something went wrong in the assignments.
        else
            return 1 # We don't have color capability.
        fi
    return 0 # We've already run this since colorsSet is true, so do nothing and report "all good" (exit status 0).
    fi
}

# ↑↑↑ END setColors
# ↓↓↓ def showColors()
showColors() {
    local _DOCSTRING="Shows a preview of all the color definitions available (hard coded)."
    local _USAGE="Usage: showColors "
    functionTracingDebug "$@"

    for color in red alertRed rustyRed seriouslyRed liabilityPink green aquaMarine cvagDark cvagMed cvagLight cvagLightest yellow peach warmOrange travexOrange lemon taxexYellow blue blueMidnight dodgerBlue fancyBlue slsbDark slsbMed slsbLight slsbLightest purple princePurpleDarkest princePurpleDark princePurple princePurpleLight powder boldOrange sunFlower tinGray cyan bold 
    do
        declare -n nameRef=$color
        echo "$nameRef$color$normal"
        unset nameRef
    done

    echo $normal
}
# ↑↑↑ END showColors

# ↓↓↓ def highlightSearchTerm()
highlightSearchTerm() {
    ## Highlights the search $term in the $string and returns the modified string.
    functionTracingDebug "$@"
    local term string word result 
    [[ ! -v highlightColor ]] && declare -n highlightColor=red # If a highlight color hasn't been chosen, set the highlightColor variable as a bash nameref to point to the value of the named color.
    declare -a termArr # Local array for the words in the search.
    declare -a stringArr # Local array for the words in the string.
    minimumArguments 2 "$@" # Define the minimum number of arguments. The function handles errors.
    { [[ "$colorsSet" == true ]] || setColors; } || return 1  # if we don't have the colors set, set them or die.
    term="$1"
    for word in $term # Using the janky word splitting feature... should be fun.
    do
        termArr+=("$word") # Append the word to the term array.
    done
    string="$2"
    result='' # An empty string to append to.
    for word in $string # Using the janky word splitting feature... should be fun.
    do
        for keyword in "${termArr[@]}" # Check each word against the keywords we seached for.
        do
            if [[ "$word" =~ (.*)"$keyword"(.*) ]]; then
                result+="${BASH_REMATCH[1]}${highlightColor}$keyword${normal}${BASH_REMATCH[2]} " # Highlight matching portion of the word and append it to the result string.
                continue 2 # Go to the next word in the string.
            fi
        done
        result+="$word " # The word wasn't a hit for our keywords, so Append the word to the result string.
    done
    echo "$result" # Return the result.
}
# ↑↑↑ END highlightSearchTerm
# ↓↓↓ def command_not_found_handle()
command_not_found_handle() { 
    #if describe "$@"; then
        #return $?
    #fi

    if [ -x /usr/lib/command-not-found ]; then
        /usr/lib/command-not-found -- "$1";
        return $?;
    fi

    if [ -x /usr/share/command-not-found/command-not-found ]; then
        /usr/share/command-not-found/command-not-found -- "$1";
        return $?;
    fi

    printf "%s: command not found\n" "$1" 1>&2;
    return 127;
}
# ↑↑↑ END command_not_found_handle
# ↓↓↓ def showme()
showme() {
    local _DOCSTRING="Shows the contents of a file with comments and newlines removed."
    local _USAGE="Usage: showme <file>"
    functionTracingDebug "$@"

    local file="$1"

    declare -A patterns
    declare -a sedArgs

    patterns[removeInlineOctothorpComments]='  s/#.*$//g'
    patterns[removeInlinePercentComments]='    s/%.*$//g'
    patterns[removeInLineJavaComments]='       s/ \/\/.*//g'
    patterns[removeOctothorpCommentLines]='     /^#.*$/d'
    patterns[removePercentCommentLines]='       /^%.*$/d'
    patterns[removeJavaCommentLines]='          /^ *\/\//d'
    patterns[removeWhitespaceOnlyLines]='       /^[\t ]*$/d'
    patterns[removeBlankLines]='                /^$/d'

    for pattern in "${patterns[@]}"
    do
        sedArgs+=(-e)
        sedArgs+=("$pattern")
    done

    if [[ "$file" == '' ]]; then # We didn't get a file argument.
        cat | sed "${sedArgs[@]}" | less
    else
        sed "${sedArgs[@]}" "$file" | less
    fi
}
# ↑↑↑ END showme


# Flow control
# ↓↓↓ def runInBackground()
runInBackground() {
    # Runs the command in $1 with all following args supplied, in the background and with output sent to /dev/null
    functionTracingDebug "$@"
    "$1" "${@:2}" 2>/dev/null >/dev/null & 
}
# ↑↑↑ END runInBackground()
# ↓↓↓ def readInput ()
readInput() {
    functionTracingDebug "$@"
    # Function signature.
    #    readInput "message" "length" 
    local answer
    local len
    if [[ "x$2" != x ]]; then # if we got $2
        len="-n $2"
    fi
    read "$len" -p "$1" answer
    echo "${answer}"
}
# ↑↑↑ END readInput
# ↓↓↓ def yesNo()
yesNo() {
    local _DOCSTRING="Asks for a response of yes or no. Returns true or false."
    local _USAGE="Usage: yesNo <question>"
    functionTracingDebug "$@"

    local  question
    minimumArguments 1 "$@" || return 3
    question=$1
    local answer

    while true
    do
        read -n 1 -p "$question"': ' answer
        echo # Adds a carage return after the answer is given. Annoying this isn't default.
        case "$answer" in
            y|Y)
                return 0
                ;;
            n|N)
                return 1
                ;;
            *)
                echo "Please try again. Type 'Y' or 'N' please."
        esac
    done
}
# ↑↑↑ END yesNo

# ↓↓↓ def raiseError() 
raiseError() {
    # Function signature.
    # error ExitStatus(int) Message(string) 
    functionTracingDebug "$@"
    echo "Error: $2" >&2 # Send error message to standard error.
}
# ↑↑↑ END raiseError()
# ↓↓↓ def raiseErrorAndExit() 
raiseErrorAndExit() {
    # Function signature.
    # error ExitStatus(int) Message(string) 
    functionTracingDebug "$@"
    echo "Error: $2" >&2 # Send error message to standard error.
    exit $1
}
# ↑↑↑ END raiseErrorAndExit()
# ↓↓↓ def warning()
warning() {
    local _DOCSTRING="Print a warning message to stderr and continue."
    local _DOCSTRING+="  Usage:  warning [message]"
    functionTracingDebug "$@"
    
    local default
    default="Something non-fatal went wrong."
    echo "Warning: ${1:-$default}" >&2 # Send error message to standard error.
}
# ↑↑↑ END warning

# Strings: manipulation & introspection 
# ↓↓↓ def spaceToDash() 
spaceToDash() {
    functionTracingDebug "$@"
    local allArgs="$*"
    echo ${allArgs// /-} # Replace spaces with dashes.
}
# ↑↑↑ END spaceToDash()
# ↓↓↓ def dashToSpace() 
dashToSpace() {
    functionTracingDebug "$@"
    echo ${*//-/ } # Replace spaces with dashes.
}
# ↑↑↑ END dashToSpace()
# ↓↓↓ def dashToUnderbar() 
dashToUnderbar() {
    functionTracingDebug "$@"
    echo ${*//-/_} # Replace dashes with underbars.
}
# ↑↑↑ END dashToUnderbar()
# ↓↓↓ def lengthOfLongestLine()
lengthOfLongestLine() {
    ## Returns the length of the longest line.
    functionTracingDebug "$@"
    local file line longestLength
    longestLength=0
    if [[ $# -gt -0 ]]; then # Check if we were given a file name. If not, read from stdin.
        file="$1"
    else
        file='-'
    fi
    while read line
    do
        [[ ${#line} -gt "$longestLength" ]] && longestLength="${#line}"
    done < <(cat "$file")
    echo "$longestLength"
    return 0
}
# ↑↑↑ END lengthOfLongestLine
# ↓↓↓ def repeatString()
repeatString() {
    local _DOCSTRING="Returns the given string repeated N times."
    local _USAGE="Usage: repeatString <string> <n>"
    functionTracingDebug "$@"

    local  string n
    minimumArguments 2 "$@" || return 3
    string=$1
    n=$2

    local returnValue
    
    printf -v returnValue '%*s' "$n"
    printf '%s\n' "${returnValue// /$string}"
}
# ↑↑↑ END repeatString
# ↓↓↓ def centerStringInString()
centerStringInString() {
    local _DOCSTRING="Centers the smaller string inside the larger string."
    local _USAGE="Usage: centerStringInString <stringA> <stringB>"
    functionTracingDebug "$@"

    local  stringA stringB big small delta frontEndText backEndText lenFront lenBack backEndStart frontAndSmall result lenBig lenSmall lenFrontAndSmall
    minimumArguments 2 "$@" || return 3
    stringA="$1"
    stringB="$2"

    local swapTemp

    if [[ "${#stringA}" -gt "${#stringB}" ]]; then
        big="$stringA"
        small="$stringB"
    else
        small="$stringA"
        big="$stringB"
    fi

    lenBig="${#big}"
    lenSmall="${#small}"

    delta="$(( lenBig - lenSmall ))"
    lenFront="$(( delta / 2 ))"

    frontEndText="${big:0:$lenFront}"
    frontAndSmall="$frontEndText$small"
    lenFrontAndSmall="${#frontAndSmall}"

    lenBack="$(( lenBig - lenFrontAndSmall ))"
    backEndStart="$(( lenBig - lenBack ))"
    backEndText="${big:$backEndStart}"
    result="$frontEndText$small$backEndText"
    #listVarsLong stringA stringB big small delta frontEndText backEndText lenFront lenBack backEndStart frontAndSmall result lenBig lenSmall lenFrontAndSmall
    echo "$result"
}
# ↑↑↑ END centerStringInString
# ↓↓↓ def middlePadStrings()
middlePadStrings() {
    local _DOCSTRING="Pads the middle of two strings with the given character to the given length."
    local _USAGE="Usage: middlePadStrings<leftString> <rightString> <length> [padCharacter=<SPACE>]"
    functionTracingDebug "$@"

    local  padCharacter length leftString rightString returnValue lenLeft lenRight rPl
    minimumArguments 3 "$@" || return 3
    leftString="$1"
    rightString="$2"
    length="$3"
    padCharacter="${4:- }"

    local padWidth padding padString

    padCharacter="${padCharacter:0:1}" # Get only the first character given.

    lenLeft="${#leftString}"
    lenRight="${#rightString}"
    rPl="$(( lenRight + lenLeft ))"
    padWidth="$(( length - rPl ))"
    padString="$(repeatString "$padCharacter" "$padWidth")"
    returnValue="$leftString$padString$rightString"
    echo "$returnValue"
}
# ↑↑↑ END middlePadStrings
# ↓↓↓ def rightJustify()
rightJustify() {
    local _DOCSTRING="Justify text on the right of [width], or the screen."
    local _USAGE="Usage: rightJustify <string> [width]"
    functionTracingDebug "$@"

    local  string width
    minimumArguments 1 "$@" || return 3
    string="$1"
    width="${2:-$COLUMNS}"
    padCharacter="${3:- }"
    padCharacter="${padCharacter:0:1}" # Get only the first character given.

    middlePadStrings '' "$string" "$width" "$padCharacter"
}
# ↑↑↑ END rightJustify
# ↓↓↓ def indentIt()
indentIt() {
    local _DOCSTRING="Indents each input line by N * '    ' (4 spaces)."
    local _USAGE="Usage: indentIt <n>"
    functionTracingDebug "$@"

    local  n
    minimumArguments 1 "$@" || return 3
    n="$1"

    local indentation

    indentation="$(repeatString '    ' "$n")"

    cat | while IFS='' read line
    do
        echo "$indentation$line"
    done
}
# ↑↑↑ END indentIt

# Paths: manipulation
# ↓↓↓ def basename()
basename() {
    ## Wraps the core-utils basename program to support reading from stdin.
    functionTracingDebug "$@"
    local bn
    bn='/usr/bin/basename'
    if [[ $# -lt 1 ]]; then
        while read filename
        do
            "$bn" "$filename"
        done < <(cat | tr -s ' ' | tr ' ' '\n')
    else
        $bn "$@"
    fi
}
# ↑↑↑ END basename

# Environment manipulation & interrogation
# ↓↓↓ def findAudioPlayer()
findAudioPlayer() {
    # Returns the full path to the first audio player it finds.
    functionTracingDebug "$@"
    local candidate 
    for candidate in mpg321 mpg123 mplayer cvlc
    do
        which "$candidate" >/dev/null && { echo $(which "$candidate"); return; }
    done
    raiseError 1 "No audio player found."
}
# ↑↑↑ END findAudioPlayer
# ↓↓↓ def setSyntaxHighlighter()
setSyntaxHighlighter() {
    local _DOCSTRING="Checks if the syntax highlighter is installed and enables or bypasses it."
    local _USAGE="Usage: setSyntaxHighlighter "
    functionTracingDebug "$@"

    if [[ ! -v _SYNTAX_HIGHLIGHTER ]]; then # Setup whether or not to use syntax highlighting.
        if [[ -x "$(which pygmentize)" ]]; then
            _SYNTAX_HIGHLIGHTER="$(which pygmentize) -l bash"
            return 0
        else
            _SYNTAX_HIGHLIGHTER="$(which cat)"
            return 1
        fi
    fi
}
# ↑↑↑ END setSyntaxHighlighter

# ↓↓↓ def weAreRunningX()
weAreRunningX() {
    ## Check if we are running an X11 server. Return true if we are and false if not.
    functionTracingDebug "$@"
    [[ -v DISPLAY ]] && return 0 || return 1 # If we are running an X11 display the $DISPLAY variable will be set.
}
# ↑↑↑ END weAreRunningX
# ↓↓↓ def cleanup()
cleanup() {
    ## this function will make sure that the environment is clean for the program to run.
    functionTracingDebug "$@"
    [[ "$DEBUG" == true ]] && :>$debugLog # erase the contents of the debug log.
}
# ↑↑↑ END cleanup
# ↓↓↓ def functions()
functions() {
    local _DOCSTRING="Lists the functions defined in the current environment."
    local _USAGE="Usage: functions "
    functionTracingDebug "$@"
    local line func extdebugSave arg filter message

    extdebugSave="$(shopt -p extdebug)"

    for arg in "$@";
    do
        case "$arg" in
            -a|--all)
                filter='cat'
                message='Functions:'
                ;;
        esac
    done
    # Set the defaults for options that weren't set by the arg parser.
    filter="${filter:-grep -v ^_}" # If we didn't get a -a option
    message="${message:-NOTICE: Private namespace hidden. Show with --all.}"
    echo "$message"
    
    shopt -s extdebug # Turn on source filename and line number printing for declare -F.
    while read -r line
    do
        func="$(echo "$line" | cut -d' ' -f 3-)" # extract the function name from the line.
        declare -F "$func" # Print the details of the source filename and line number for definition.
    done < <(declare -F) | column -t | sort -k3 | $filter | less # Feed in the currently definedd functions, and format the output.
    $extdebugSave # Set it back to what it was before.
}
# ↑↑↑ END functions
# ↓↓↓ def vars()
vars() {
    local _DOCSTRING="Prints out the variables set in the environment."
    functionTracingDebug "$@"
    declare -p | grep '^declare -[-aAx] '
}
# ↑↑↑ END vars
# ↓↓↓ def locals()
locals() {
    local locals_assignment locals_k locals_v
    local -p | while read -r locals_assignment
    do
        locals_k="${locals_assignment%%=*}"
        locals_v="${locals_assignment#*=}"
        listVarsLong locals_k locals_v locals_assignment
        echo "    [$locals_k]  |-->  \"$locals_v\"" # Echo an indented key and value pair: [key]  -->  "value"
    done | column -t -s '|' 
}
# ↑↑↑ END locals
# ↓↓↓ def listVars()
listVars() {
    local _DOCSTRING="Pretty print the name and value of each variable name supplied in a single line."
    local _USAGE="Usage: listVars names of vars"
    functionTracingDebug "$@"

    local varName indent

    while [[ "$1" =~ ^--.*= ]]
    do
        case "$1" in
            --indent)
                indent="${1##*=}"
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    echo -n "$indent    "
    for varName in "$@"
    do
        declare -n nameRefToVar=$varName
        echo -n "$dodgerBlue$varName$normal --> $purple$nameRefToVar$normal;  "
    done
    echo
}
# ↑↑↑ END listVars
# ↓↓↓ def listVarsLong()
listVarsLong() {
    local _DOCSTRING="Pretty print the name and value of each variable name supplied."
    local _USAGE="Usage: listVars names of vars"
    functionTracingDebug "$@"

    local varName indent

    while [[ "$1" =~ ^--.*= ]]
    do
        case "$1" in
            --indent)
                indent="${1##*=}"
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    echo
    { for varName in "$@"
    do
        declare -n nameRefToVar=$varName
        echo "$indent    $dodgerBlue$varName$normal |--> $purple$nameRefToVar$normal"
    done; } | column -s'|' -t
}
# ↑↑↑ END listVars
# ↓↓↓ def imports()
imports() {
    local _DOCSTRING="Lists the files 'imported' with '. file' or 'source file', provided that file has a tracing line at the end. See the last line in .bash_utility_functions for an example."
    local _USAGE="Usage: imports "
    functionTracingDebug "$@"

    array _importsArray
}
# ↑↑↑ END imports



# Function aids & interrogation
# ↓↓↓ def listArgs()
listArgs() {
    ## Lists the arguments sent to it, in a readable, numbered, quoted list.
    local arg list 
    declare -i count # Make a counter using bash's "integer" type.
    list=''
    while [[ ${#@} -gt -0 ]] # Build the arg list.
    do
        count+=1
        list+="[$count]: \"$1\", "
        shift # Pop the stack of args. 
    done
    echo "$list" # Return the list.
}
# ↑↑↑ END listArgs
# ↓↓↓ def listArgsLong()
listArgsLong() {
    local _DOCSTRING="Pretty prints the argv args."
    local argList=( "$@" )
    array argList # Using the function "array" from ~/.bash/.bash_array_functions
}
# ↑↑↑ END listArgsLong
# ↓↓↓ def minimumArguments()
minimumArguments() {
    ## Checks for a minimum number of arguments. Perhaps later this could be expanded into "argumentSpecs" and would pass/fail baised on specific parameters we are looking for in our arguments.
    # Call:   minimumArguments <minimumArgumentsRequired> <arguments>
    local minimumArgumentsRequired numberOfArgsSupplied callingFunction
    callingFunction="${FUNCNAME[1]}"
    minimumArgumentsRequired="$1"
    shift # clear $1 and shift all args down one.
    numberOfArgsSupplied="$#"
    [[ "$minimumArgumentsRequired" =~ [^0-9] ]] && raiseError 3 "${callingFunction}: Invalid non-integer 'minimum number of arguments' argument supplied." && return 3 # if we have anything but a number as input, error out.
    [[ "$numberOfArgsSupplied" -lt "$minimumArgumentsRequired" ]] && raiseError 3 "${callingFunction}: Too few arguments. Got $numberOfArgsSupplied of the $minimumArgumentsRequired required: $(listArgs "$@") " && return 3 # If there is a miss-match in the number of arguments, report an error, naming the parent function.
    return 0 # Success. There are the correct number of arguments.
}
# ↑↑↑ END minimumArguments
# ↓↓↓ def getDocstring()
getDocstring() {
    local _DOCSTRING="Returns the docstring of the defined function."
    local _USAGE="Usage: getDocstring <func>"
    functionTracingDebug "$@"

    local  func docline docstring
    minimumArguments 1 "$@" || return 3
    func="$1"

    docline="$(describeFunction -n "$func" | sed -n '6 p')"
    if [[ "$docline" =~ _DOCSTRING ]]; then
        docstring="${docline/*local _DOCSTRING=\"/}"
        docstring="${docstring%%\";}"
        echo "$docstring"
    else
        echo "NONE"
    fi
}
# ↑↑↑ END getDocstring

# Operators, tests, and boolians
# ↓↓↓ def varsafe()
varsafe() {
    ## Sanatizes a string to be safe as a variable name.
    functionTracingDebug "$@"
    local line safeString
    if [[ $# -lt 1 ]]; then 
        while read line
        do
            $FUNCNAME "$line" # Call self recursively.
        done
    else
        safeString="$(echo "$1" | sed 's/^[^_a-zA-Z]*\([_a-zA-Z][_a-zA-Z0-9]*\).*/\1/g')"
        if [[ "$safeString" != '' ]]; then
            echo "$safeString"
        fi
    fi
    
}
# ↑↑↑ END varsafe
# ↓↓↓ def max()
max() {
    local _DOCSTRING="Returns the max of two arguments."
    local _USAGE="Usage: max <a> <b>"
    functionTracingDebug "$@"

    local  a b result
    minimumArguments 2 "$@" || return 1 # Returns false if there are not enough arguments.
    a=$1
    b=$2
    if [[ ! "$a" =~ [0-9]* ]] || [[ ! "$b" =~ [0-9]* ]]; then # Check input to be integers.
        return 1 # Return false if an argument is not an int.
    fi
    [[ "$a" -gt "$b" ]] && result="$a" || result="$b" # Set $result to the larger of $a and $b.
    echo "$result" # Return the result.
}
# ↑↑↑ END max
# ↓↓↓ def min()
min() {
    local _DOCSTRING="Returns the max of two arguments."
    local _USAGE="Usage: max <a> <b>"
    functionTracingDebug "$@"

    local  a b result
    minimumArguments 2 "$@" || return 1 # Returns false if there are not enough arguments.
    a=$1
    b=$2
    if [[ ! "$a" =~ [0-9]* ]] || [[ ! "$a" =~ [0-9]* ]]; then # Check input to be integers.
        return 1 # Return false if an argument is not an int.
    fi
    [[ "$a" -lt "$b" ]] && result="$a" || result="$b" # Set $result to the larger of $a and $b.
    echo "$result" # Return the result.
}
# ↑↑↑ END min

# Filesystem interrogation
# ↓↓↓ def regularWritable()
regularWritable() {
    local _DOCSTRING="Returns bool (true/false) if file is/not a regular file and writable by the current user."
    local _USAGE="Usage: regularWritable <file>"
    functionTracingDebug "$@"

    local  file
    minimumArguments 1 "$@" || return 3
    file="$1"

    if [[ -f "$file" ]] && [[ -w "$file" ]]; then
        return 0
    else
        return 1
    fi
}
# ↑↑↑ END regularWritable
# ↓↓↓ def latestFileInDir()
latestFileInDir() {
    local _DOCSTRING="Returns the name (no path) of the file most recently modified in the supplied directory, or PWD if none. (taken from wooledge.org)"
    local _USAGE="Usage: latestFileInDir [dir=.]"
    functionTracingDebug "$@"

    local  dir 
    minimumArguments 0 "$@" || return 3 
    dir=${1:-.}

    local file latest justTheFilename

    for file in in "${dir}"/*
    do
        if [[ "$file" -nt "$latest" ]]; then 
            latest="$file"
        fi
    done
    justTheFilename="$(basename "$latest")"
    echo "$justTheFilename" 
}
# ↑↑↑ END latestFileInDir
# ↓↓↓ def newestFileInDir()
newestFileInDir() {
    local _DOCSTRING="Same as latestFileInDir."
    latestFileInDir "$@"
}
# ↑↑↑ END newestFileInDir
# ↓↓↓ def latestFile()
latestFile() {
    local _DOCSTRING="Wrapper for latestFileInDir."
    latestFileInDir
}
# ↑↑↑ END latestFile
# ↓↓↓ def oldestFileInDir()
oldestFileInDir() {
    local _DOCSTRING="Returns name (no path) of the file least recently modified in the supplied directory, or PWD if none. (modified from from wooledge.org)"
    local _USAGE="Usage: oldestFileInDir [dir=.]"
    functionTracingDebug "$@"

    local  dir
    minimumArguments 0 "$@" || return 3 # Quits the entire script if there are not enough arguments.
    dir="${1:-.}"

    local files fileUnderTest oldestFileFound justTheFilename
    files=("${1:-.}"/*) # Glob of all files in dir. THERE IS AN EDGE CASE BUG. IT DOESN'T INCLUDE DOT FILES (.file). See shopt -s dotglob.
    oldestFileFound="${files[0]}"
    for fileUnderTest in "${files[@]}"
    do
        [[ "$fileUnderTest" -ot "$oldestFileFound" ]] && oldestFileFound="$fileUnderTest"
    done

    justTheFilename="$(basename "$oldestFileFound")"

    printf '%s\n' "$justTheFilename"
}
# ↑↑↑ END oldestFileInDir
# ↓↓↓ def mostRecentlyModifiedDirectory()
mostRecentlyModifiedDirectory() {
    local _DOCSTRING="Returns the basename of the most recently modified directory at the optional [dir]."
    local _USAGE="Usage: mostRecentlyModifiedDirectory [dir]"
    local  dir
    dir=${1:-.}

    local file latest

    for file in in "${dir}"/*
    do
        if [[ -d "$file" ]] && [[ "$file" -nt "$latest" ]]; then 
            latest="$file"
        fi
    done
    if [[ "$latest" == '' ]]; then
        return 1
    else
        printf '%s\n' "$latest" 
    fi
}
# ↑↑↑ END mostRecentlyModifiedDirectory
# ↓↓↓ def numberOfFilesInDir()
numberOfFilesInDir() {
    local _DOCSTRING="prints the number of files in the specified directory, or pwd."
    local _USAGE="Usage: numberOfFilesInDir [dir=.]"
    local  dir filesInDir

    dir=${1:-.}

    filesInDir=( $dir/* )

    echo "${#filesInDir[*]}"
}
# ↑↑↑ END numberOfFilesInDir
# ↓↓↓ def numberOfsubDirs()
numberOfsubDirs() {
    local _DOCSTRING="prints the number of subdirectories in the specified directory, or pwd."
    local _USAGE="Usage: numberOfsubDirs [dir=.]"
    local  dir subdirs f count

    dir=${1:-.}

    for f in "$dir"/*
    do
        [[ -d "$f" ]] && ((count++))
    done

    echo "$count"
}
# ↑↑↑ END numberOfsubDirs
## BTRFS Specific interrogations
# ↓↓↓ def numberOfSubvols()
numberOfSubvols() {
    local _DOCSTRING="Prints the number of BTRFS subvolumes in the specified directory, or pwd. (Does not decent the tree to search recursively.)"
    local _USAGE="Usage: numberOfSubvols [dir=.]"
    functionTracingDebug "$@"
    local  dir subvols f count

    dir=${1:-.}

    for f in "$dir"/*
    do
        isSubvolume "$f" && ((count++)) # If $f is a subvol, increase the count. Throw out any output from the BTRFS command.
    done
    echo "$count"
}
# ↑↑↑ END numberOfSubvols
# ↓↓↓ def isSubvolume()
isSubvolume() {
    local _DOCSTRING="Returns true/false depending on if the supplied dir (or pwd) is a btrfs subvolume."
    local _USAGE="Usage: isSubvolume [dir=.]"
    functionTracingDebug "$@"

    local  dir 
    dir=${1:-.}

    local inode fstype
    inode="$(stat -c %i "$dir")"
    fstype="$(stat -f -c %T "$dir")"
    if [[ "$inode" == 256 ]] && [[ "$fstype" == btrfs ]]; then
        return 0
    else
        return 1
    fi
}
# ↑↑↑ END isSubvolume
# ↓↓↓ def btrfsSubvolCreationTimeEpoc()
btrfsSubvolCreationTimeEpoc() {
    local _DOCSTRING="Return the epoc time for the creation of a btrfs subvolume."
    local _USAGE="Usage: btrfsSubvolCreationTimeEpoc <path>"
    functionTracingDebug "$@"

    local  path
    minimumArguments 1 "$@" || return 3
    path=$1

    local timestamp epocTime 

    if ! isSubvolume "$path"; then
        dbFail "$path is not a BTRFS subvolume"; return 1
    fi
    timestamp="$(sudo btrfs subvolume show "$path" | grep 'Creation time' | tr '\t' ' ')"
    timestamp="${timestamp:18:19}" # Just rely on the format of the output... I'm sure this is a terible idea...
    
    epocTime="$(date -d "$timestamp" '+%s')" # Convert time to seconds since 01/01/1970.
    echo "$epocTime"
}
# ↑↑↑ END btrfsSubvolCreationTimeEpoc
# ↓↓↓ def oldestSnapshotInDir()
oldestSnapshotInDir() {
    local _DOCSTRING="Returns the name (no path) of the BTRFS snapshot least recently modified in the supplied directory, or PWD if none. (modified from from wooledge.org)"
    local _USAGE="Usage: oldestFileInDir [dir=.]"
    functionTracingDebug "$@"

    local  dir
    dir="${1:-.}"

    local files fileUnderTest snapshotUnderTest oldestSnapshotFound justTheFilename snapshots oldestTimestamp timestampOfFileUnderTest
    files=("${1:-.}"/*) # Glob of all files in dir. THERE IS AN EDGE CASE BUG. IT DOESN'T INCLUDE DOT FILES (.file). See shopt -s dotglob.
    for fileUnderTest in "${files[@]}" # Filter for subvolumes
    do
        isSubvolume "$fileUnderTest" && snapshots+=( "$fileUnderTest" )
    done

    oldestSnapshotFound="${snapshots[0]}" # A guess to start with.
    oldestTimestamp="$(btrfsSubvolCreationTimeEpoc "$oldestSnapshotFound")"
    for snapshotUnderTest in "${snapshots[@]}"
    do
        timestampOfFileUnderTest="$(btrfsSubvolCreationTimeEpoc "$snapshotUnderTest")"
        if [[ "$timestampOfFileUnderTest" < "$oldestTimestamp" ]]; then # We found a new "oldest".
            oldestSnapshotFound="$snapshotUnderTest"
            oldestTimestamp="$timestampOfFileUnderTest"
        fi
    done

    justTheFilename="$(basename "$oldestSnapshotFound")"

    echo "$justTheFilename"
}
# ↑↑↑ END oldestFileInDir

# DATE LOGIC
# ↓↓↓ def listDaysOfMonth()
listDaysOfMonth() {
    local _DOCSTRING="Returns a string of numerical days of the month provided, i.e., \"01 02 ... 30 31\""
    local _USAGE="Usage: listTheDaysOfTheMonth <month> [year]"
    functionTracingDebug "$@"

    local  month year
    minimumArguments 1 "$@" || return 3
    month="$1"
    year="${2-$(date '+%Y')}" # defaults to current year.

    local month domSet thisYear nextYear

    thisYear="$year"
    nextYear="$(( year + 1 ))"

    case "$month" in
        # 31-day Months
        #     JAN MAR MAY JUL AUG OCT DEC
        01|03|05|07|08|10|12)
            domSet="$(echo {01..31})"
            ;;
        # 30-day Months
        #     APR JUN SEP NOV
        04|06|09|11)
            domSet="$(echo {01..30})"
            ;;
        # February check.
        #  Is leap-year -- YEAR %% 4
        02)
            if [[ $(( year % 4 )) == 0 ]]; then # It's a leep year.
                # 0 -- 29 days
                domSet="$(echo {01..29})"
            else
                # non-0 -- 28 days
                domSet="$(echo {01..28})"
            fi
            ;;
        *)
            dbFail "Month is $month. Needs to be 0 < month < 13." ; return 1
    esac
    echo "$domSet"
}
# ↑↑↑ END listDaysOfMonth

# Directories and files
# ↓↓↓ def mkcd()
mkcd() {
    local _DOCSTRING="Make a directory and change directory into it."
    local _USAGE="Usage: mkcd [mkdir-options] <dir>"
    functionTracingDebug "$@"

    local  dir
    minimumArguments 1 "$@" || return 3

    local args=( "$@" )
    idx=$(( ${#args[*]} - 1 ))
    dir="${args["$idx"]}"

    mkdir "$@" && cd "$dir"
}
# ↑↑↑ END mkcd

# Finding help
# ↓↓↓ def webSearch()
webSearch() {
    local _DOCSTRING="Do a web search for the arguments in Elinks."
    local _USAGE="Usage:  "
    functionTracingDebug "$@"

    local search="$*"

    local encoded="$(python -c "import urllib, sys; print urllib.quote(sys.argv[1])" "$search")"

    elinks "https://lite.duckduckgo.com/lite/?q=$encoded"
}
alias ?=webSearch
# ↑↑↑ END webSearch


. $HOME/.bash/.bash_describe # The describe suite.

_importsArray[utility_functions]="$(( ${_importsArray[utility_functions]} + 1 ))"
